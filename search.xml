<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用LRU机制实现K-V存储结构</title>
      <link href="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>  本题是我在面试时遇到的，当时的想法是使用<code>HashMap</code> + <code>PriorityQueue</code>实现，后经学习发现有时间复杂度更小的解决办法，特此记录</p><h2 id="LRU原理"><a href="#LRU原理" class="headerlink" title="LRU原理"></a>LRU原理</h2><p>即最近最少使用，属于典型的内存淘汰机制</p><p>通俗的说，LRU算法认为，最近被频繁访问的数据会具备更高的留存，淘汰那些不常被访问的数据。</p><h2 id="首先分析下PriorityQueue"><a href="#首先分析下PriorityQueue" class="headerlink" title="首先分析下PriorityQueue"></a>首先分析下<code>PriorityQueue</code></h2><p><code>PriorityQueue</code>使用小顶堆实现，<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em></p><p>如果使用<code>PriorityQueue</code>，以当前时间戳最大以大顶堆为基础构建，那每添加&#x2F;获取一个新元素都需要重新调整优先队列，每次操作时间复杂度近似于O(logN)</p><p><strong>使用双向链表构建</strong></p><p>首先使用HashMap存储key，可以做到insert和get时间复杂度为O(1)，value存储在双向链表里</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1.png"></p><p>head 和 tail 分别指向双向链表的头尾，若双向链表达到容量上限，则直接淘汰尾部，新增操作则将新的节点插入到双向链表头部，get则将对应的节点挪到链表头部</p><h3 id="Redis的LRU实现"><a href="#Redis的LRU实现" class="headerlink" title="Redis的LRU实现"></a>Redis的LRU实现</h3><p>上述使用双向链表的缺陷是需要存放额外的next和prev指针，会对存储空间造成一定的浪费，故Redis采用随机取出若干个key，按访问时间排序，淘汰掉最久未使用的</p><p>Redis整体上是一个大的dict, key是一个string, 而value都会保存为一个robj</p><p>为了支持LRU，Redis使用一个全局LRU时钟，定时更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">//LRU_BITS为24bit</span></span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>每次获取一个值时，都更新value里面的lru字段为当前时间戳</p><p>Redis初始实现LRU算法比较简单，就是从dic里取出5个key， 淘汰其中时间戳最小的</p><p>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按LRU大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/2.png"></p><p>基于此算法进行的模拟表明增加了pool后效果比随机取5个key好一些，但是仍然存在淘汰最近常使用的key的情况，故作者提出新的思路：<strong>如果能够记录一个key被访问的次数,那么经常被访问的key最有可能再次被访问到</strong>，即LFU，访问次数最少被逐出</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="built_in">LFUDecrAndReturn</span>(val);<span class="comment">//首先计算是否需要将counter衰减</span></span><br><span class="line">    counter = <span class="built_in">LFULogIncr</span>(counter);<span class="comment">//根据上述返回的counter计算新的counter</span></span><br><span class="line">    val-&gt;lru = (<span class="built_in">LFUGetTimeInMinutes</span>()&lt;&lt;<span class="number">8</span>) | counter; <span class="comment">//robj中的lru字段只有24bits,lfu复用该字段。高16位存储一个分钟数级别的时间戳，低8位存储访问计数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;<span class="comment">//原来保存的时间戳</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//原来保存的counter</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? <span class="built_in">LFUTimeElapsed</span>(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//server.lfu_decay_time默认为1,每经过一分钟counter衰减1</span></span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;<span class="comment">//如果需要衰减,则计算衰减后的值</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;<span class="comment">//counter最大只能存储到255,到达后不再增加</span></span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)<span class="built_in">rand</span>()/RAND_MAX;<span class="comment">//算一个随机的小数值</span></span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;<span class="comment">//新加入的key初始counter设置为LFU_INIT_VAL,为5.不设置为0的原因是防止直接被逐出</span></span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//server.lfu_log_facotr默认为10</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;<span class="comment">//可以看到,counter越大,则p越小，随机值r小于p的概率就越小。换言之,counter增加起来会越来越缓慢</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;<span class="comment">//获取分钟级别的时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LRU本质上是一个概率计数器，称为morris counter.随着访问次数的增加,counter的增加会越来越缓慢。如下是访问次数与counter值之间的关系</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.png"></p><p>factor即server.lfu_log_facotr配置值，默认为10.可以看到,一个key访问一千万次以后counter值才会到达255.factor值越小, counter越灵敏</p><p>lfu随着分钟数对counter做衰减是基于一个原理:过去被大量访问的key不一定现在仍然会被访问。相当于除了计数，给时间也增加了一定的权重。</p><p>淘汰时就很简单了，仍然是一个pool,随机选取10个key,counter最小的被淘汰</p><p>参考文档：<a href="https://segmentfault.com/a/1190000017555834">【Redis源码分析】Redis中的LRU算法实现 - SegmentFault 思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试小记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL使用基础</title>
      <link href="/2021/04/15/MySQL%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/15/MySQL%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><ul><li>外键并不是通过列名实现的，而是通过定义外键约束实现的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><ul><li>删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><ul><li><p>多对多通过一个中间表（关系表）关联两个一对多关系形成多对多关系</p></li><li><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>对<code>score</code>列创建索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>​使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上<code>ADD INDEX idx_name_score (name, score);</code></p><p>​索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。</p><p>​索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引。</p><ul><li>唯一索引</li></ul><p>不适宜作为主键，但又具备唯一性约束，可以添加唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>也可以只创建唯一约束而不创建唯一索引，仍具备唯一性保证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ul><li>查询数据库表的数据，我们使用如下的SQL语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure><ul><li>条件查询的语法就是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure><ul><li>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>，<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，<code>NOT &lt;条件&gt;</code></li></ul><p>用小括号<code>()</code>表示如何进行条件的组合：</p><p><code>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#39;M&#39;;</code></p><ul><li><h3 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h3><table><thead><tr><th align="left">条件</th><th align="left">表达式举例1</th><th align="left">表达式举例2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">使用&#x3D;判断相等</td><td align="left">score &#x3D; 80</td><td align="left">name &#x3D; ‘abc’</td><td align="left">字符串需要用单引号括起来</td></tr><tr><td align="left">使用&gt;判断大于</td><td align="left">score &gt; 80</td><td align="left">name &gt; ‘abc’</td><td align="left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td align="left">使用&gt;&#x3D;判断大于或相等</td><td align="left">score &gt;&#x3D; 80</td><td align="left">name &gt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;判断小于</td><td align="left">score &lt; 80</td><td align="left">name &lt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;&#x3D;判断小于或相等</td><td align="left">score &lt;&#x3D; 80</td><td align="left">name &lt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;&gt;判断不相等</td><td align="left">score &lt;&gt; 80</td><td align="left">name &lt;&gt; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用LIKE判断相似</td><td align="left">name LIKE ‘ab%’</td><td align="left">name LIKE ‘%bc%’</td><td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table></li><li><p>可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p></li><li><p>使用<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>时，还可以给每一列起个别名，结果集的列名就会被别名替换。</p></li><li><p>查询结果通常根据主键排序，可以加上<code>ORDER BY</code>子句，按照对应的查找条件由低到高排序。</p></li></ul><p>eg：<code>SELECT id, name, gender, score FROM students ORDER BY score;</code></p><p>默认采用<code>ASC</code>排序规则，即升序。可以加上<code>DESC</code>表示“倒序”：<code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code></p><p>若要进一步增加排序条件可以继续添加列名。</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li><p><code>LIMIT</code>总是设定为<code>pageSize</code>；</p></li><li><p><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</p><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p></li></ul><p>MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>使用SQL内置的<code>COUNT()</code>函数查询</p><p>SELECT COUNT(内容)  别名 FROM students;</p><p>还有如下聚合函数：</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SUM</td><td align="left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td align="left">AVG</td><td align="left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td align="left">MAX</td><td align="left">计算某一列的最大值</td></tr><tr><td align="left">MIN</td><td align="left">计算某一列的最小值</td></tr></tbody></table><p><code>GROUP BY</code>执行分组，会把<code>class_id</code>相同的列先分组，再分别计算</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p><code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</p><p>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</p><p>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</p><p>使用最常用的一种内连接——INNER JOIN</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>eg：<code>SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</code><br><code>FROM students s</code><br><code>INNER JOIN classes c</code><br><code>ON s.class_id=c.id;</code></p><p>OUT JOIN</p><p>包括：LEFT  RIGHT FULL</p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" alt="left-outer-join"></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" alt="right-outer-join"></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" alt="full-outer-join"></p><h2 id="数据库的增删查改"><a href="#数据库的增删查改" class="headerlink" title="数据库的增删查改"></a>数据库的增删查改</h2><ul><li><p>INSERT：插入新记录；</p></li><li><p>UPDATE：更新已有记录；</p></li><li><p>DELETE：删除已有记录。</p></li><li><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure></li><li><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br></pre></td></tr></table></figure></li><li><p><code>UPDATE</code>语句可以没有<code>WHERE</code>条件</p></li><li><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure></li></ul><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><p>列出所有数据库：show databases;</p><p><code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库</p><p>创建新数据库：create database+数据库名称；</p><p>删除数据库：DROP DATABASE test;</p><p>创建新的数据表：CREATE TABLE table_name；</p><p>对数据库操作前，需要将操作对象更改为当前数据库：use + 数据库名；</p><p>列出当前数据库包含的所有表：show tables；</p><p>查看表的结构:desc +表名；</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
