<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中注解的实现</title>
      <link href="/2022/06/08/Java%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/06/08/Java%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>Java中注解的实现原理小记</p><span id="more"></span><h2 id="注解简介"><a href="#注解简介" class="headerlink" title="注解简介"></a>注解简介</h2><p>从Java源码可以看到， 注解的本质是一个接口，</p><p><img src="/2022/06/08/Java%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</span><br></pre></td></tr></table></figure><p>注解携带的是元数据，但不会对被注释的代码逻辑产生影响</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解即注解的注解，java中的元注解有：</p><ul><li>@Target</li><li>@Retention</li><li>@Document</li><li>@Inherited</li></ul><p>元注解<strong>只在定义注解时使用</strong></p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>指定被修饰注解的作用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到value是一个数组，即注解的作用对象可以是多个，取值范围都在ElementType</p><p>这个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口、枚举定义 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** 字段，包括枚举值 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造方法 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 元注解 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包定义 */</span></span><br><span class="line">    PACKAGE...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>指定被修饰的注解的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到Retention注解带有一个RetentionPolicy的枚举值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     *编译时可见， 编译完成被丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     *编译完写入class文件，但在类加载后被丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *注解会一直起作用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>表示是否添加到 <code>java doc</code>中</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>表示注解是否被继承</p><h2 id="获取注解数据"><a href="#获取注解数据" class="headerlink" title="获取注解数据"></a>获取注解数据</h2><p>首先如果需要在业务中使用注解传递元数据，那么注解必须是<strong>RUNTIME</strong>，否则其在编译或类加载阶段即被丢弃</p><p>注解数据的获取基于反射机制</p><p>反射中常用的类：<code>Class</code>， <code>Method</code>， <code>Field</code>均实现了<code>AnnotatedElement</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnnotatedElement</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否有注解</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定类型的注解</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; T <span class="title function_">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有注解</span></span><br><span class="line">    Annotation[] getAnnotations();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型获得注解</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取声明的注解</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; T <span class="title function_">getDeclaredAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类型获取声明的注解</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取声明注解列表</span></span><br><span class="line">    Annotation[] getDeclaredAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Anno &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;qian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoTest</span> &#123;</span><br><span class="line">    <span class="meta">@Anno(&quot;hello world&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> AnnoTest.class;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">            <span class="type">Anno</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(Anno.class);</span><br><span class="line">            System.out.println(anno.value());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其次注解的接口并没有被实现，那么我们时如何通过调用<code>value()</code>方法获取到<code>hello world</code>的呢，主要是通过动态代理。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法回顾</title>
      <link href="/2022/05/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>比较常见的排序算法大致可以分为两类：比较类排序和非比较类排序，本文接下来主要介绍各种排序算法的主要实现思想以及其时间&#x2F;空间复杂度，稳定性的分析</p><span id="more"></span><h1 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h1><p>主要有：</p><ul><li><p>交换排序：冒泡排序，快速排序</p></li><li><p>插入排序：简单插入排序， 希尔排序</p></li><li><p>选择排序：简单选择排序， 堆排序</p></li><li><p>归并排序：二路归并排序， 多路归并排序</p></li></ul><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>步骤</strong>：比较相邻元素，如果第一个比第二个大，即进行交换；对每一对相邻元素都做同样的操作，每一轮会将当前未排序数组的最大的数排在数组的末端</p><p><strong>平均时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最坏时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最好时间复杂度</strong>：O(n)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：稳定</p><p><em>注：根据以下算法，最优时间复杂度仍然是O(n<sup>2</sup>)， 可以增加一个didSwap标志，如果产生交换则置true，每轮完成后对didSwap进行判断，如果此时didSwap为false，说明数组有序，则可终止循环，此时时间复杂度为O(n)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span>  <span class="operator">=</span> nums[j + <span class="number">1</span>];</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>平均时间复杂度</strong>：O(nlogn)</p><p><strong>最坏时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最好时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(logn)</p><p><strong>稳定性</strong>：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">       <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[left];</span><br><span class="line">       <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= base) &#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= base) &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">           nums[j] = nums[i];</span><br><span class="line">           nums[i] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       nums[left] = nums[i];</span><br><span class="line">       nums[i] = base;</span><br><span class="line">       </span><br><span class="line">       quickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">       quickSort(nums, i + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><p><strong>平均时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最坏时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最好时间复杂度</strong>：O(n)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &lt;= cur) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + <span class="number">1</span>] = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>是简单插入排序的改进版，不同之处在于它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p><p>希尔排序的时间复杂度与增量的选取有关，时间复杂度在O(n^(1,3~2))</p><p><strong>平均时间复杂度</strong>：与增量有关</p><p><strong>最坏时间复杂度</strong>：与增量有关</p><p><strong>最好时间复杂度</strong>：O(n)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap;</span><br><span class="line">       <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">       <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp) &#123;</span><br><span class="line">           nums[j + gap] = nums[j];</span><br><span class="line">           j -= gap;</span><br><span class="line">       &#125;</span><br><span class="line">       nums[j + gap] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><p>采用分治法将已有的子序列合并得到完全有序的序列</p><p><strong>平均时间复杂度</strong>：O(nlogn)</p><p><strong>最坏时间复杂度</strong>：O(nlogn)</p><p><strong>最好时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(n)</p><p><strong>稳定性</strong>：稳定</p><p><em>java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//二路归并排序</span></span><br><span class="line">        <span class="comment">//定义一个存放每次归并结果的数组，可以减少每次归并反复开辟</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        divide(nums, <span class="number">0</span>, n - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums)</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            divide(nums, left, mid, temp);</span><br><span class="line">            divide(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            merge(nums, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[index] =  nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[index++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            nums[left++] = temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h3><p>在未排序序列找到最小的元素然后交换到当前排序队列的末尾，如此循环直到所有元素排序完毕</p><p><strong>平均时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最坏时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>最好时间复杂度</strong>：O(n<sup>2</sup>)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; n; j++) &#123;</span><br><span class="line">        min = nums[min] &lt;= nums[j] ? min : j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[min];</span><br><span class="line">    nums[min] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>用堆这种数据结构所设计的一种排序算法</p><ul><li><strong>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ul><p><strong>平均时间复杂度</strong>：O(nlogn)</p><p><strong>最坏时间复杂度</strong>：O(nlogn)</p><p><strong>最好时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用LRU机制实现K-V存储结构</title>
      <link href="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>  本题是我在面试时遇到的，当时的想法是使用<code>HashMap</code> + <code>PriorityQueue</code>实现，后经学习发现有时间复杂度更小的解决办法，特此记录</p><span id="more"></span><h2 id="LRU原理"><a href="#LRU原理" class="headerlink" title="LRU原理"></a>LRU原理</h2><p>即最近最少使用，属于典型的内存淘汰机制</p><p>通俗的说，LRU算法认为，最近被频繁访问的数据会具备更高的留存，淘汰那些不常被访问的数据。</p><h2 id="首先分析下PriorityQueue"><a href="#首先分析下PriorityQueue" class="headerlink" title="首先分析下PriorityQueue"></a>首先分析下<code>PriorityQueue</code></h2><p><code>PriorityQueue</code>使用小顶堆实现，<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em></p><p>如果使用<code>PriorityQueue</code>，以当前时间戳最大以大顶堆为基础构建，那每添加&#x2F;获取一个新元素都需要重新调整优先队列，每次操作时间复杂度近似于O(logN)</p><p><strong>使用双向链表构建</strong></p><p>首先使用HashMap存储key，可以做到insert和get时间复杂度为O(1)，value存储在双向链表里</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1.png"></p><p>head 和 tail 分别指向双向链表的头尾，若双向链表达到容量上限，则直接淘汰尾部，新增操作则将新的节点插入到双向链表头部，get则将对应的节点挪到链表头部</p><h3 id="Redis的LRU实现"><a href="#Redis的LRU实现" class="headerlink" title="Redis的LRU实现"></a>Redis的LRU实现</h3><p>上述使用双向链表的缺陷是需要存放额外的next和prev指针，会对存储空间造成一定的浪费，故Redis采用随机取出若干个key，按访问时间排序，淘汰掉最久未使用的</p><p>Redis整体上是一个大的dict, key是一个string, 而value都会保存为一个robj</p><p>为了支持LRU，Redis使用一个全局LRU时钟，定时更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">//LRU_BITS为24bit</span></span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>每次获取一个值时，都更新value里面的lru字段为当前时间戳</p><p>Redis初始实现LRU算法比较简单，就是从dic里取出5个key， 淘汰其中时间戳最小的</p><p>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按LRU大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/2.png"></p><p>基于此算法进行的模拟表明增加了pool后效果比随机取5个key好一些，但是仍然存在淘汰最近常使用的key的情况，故作者提出新的思路：<strong>如果能够记录一个key被访问的次数,那么经常被访问的key最有可能再次被访问到</strong>，即LFU，访问次数最少被逐出</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="built_in">LFUDecrAndReturn</span>(val);<span class="comment">//首先计算是否需要将counter衰减</span></span><br><span class="line">    counter = <span class="built_in">LFULogIncr</span>(counter);<span class="comment">//根据上述返回的counter计算新的counter</span></span><br><span class="line">    val-&gt;lru = (<span class="built_in">LFUGetTimeInMinutes</span>()&lt;&lt;<span class="number">8</span>) | counter; <span class="comment">//robj中的lru字段只有24bits,lfu复用该字段。高16位存储一个分钟数级别的时间戳，低8位存储访问计数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;<span class="comment">//原来保存的时间戳</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//原来保存的counter</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? <span class="built_in">LFUTimeElapsed</span>(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//server.lfu_decay_time默认为1,每经过一分钟counter衰减1</span></span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;<span class="comment">//如果需要衰减,则计算衰减后的值</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;<span class="comment">//counter最大只能存储到255,到达后不再增加</span></span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)<span class="built_in">rand</span>()/RAND_MAX;<span class="comment">//算一个随机的小数值</span></span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;<span class="comment">//新加入的key初始counter设置为LFU_INIT_VAL,为5.不设置为0的原因是防止直接被逐出</span></span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//server.lfu_log_facotr默认为10</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;<span class="comment">//可以看到,counter越大,则p越小，随机值r小于p的概率就越小。换言之,counter增加起来会越来越缓慢</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;<span class="comment">//获取分钟级别的时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LRU本质上是一个概率计数器，称为morris counter.随着访问次数的增加,counter的增加会越来越缓慢。如下是访问次数与counter值之间的关系</p><p><img src="/2022/04/14/%E5%88%A9%E7%94%A8LRU%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0K-V%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.png"></p><p>factor即server.lfu_log_facotr配置值，默认为10.可以看到,一个key访问一千万次以后counter值才会到达255.factor值越小, counter越灵敏</p><p>lfu随着分钟数对counter做衰减是基于一个原理:过去被大量访问的key不一定现在仍然会被访问。相当于除了计数，给时间也增加了一定的权重。</p><p>淘汰时就很简单了，仍然是一个pool,随机选取10个key,counter最小的被淘汰</p><p>参考文档：<a href="https://segmentfault.com/a/1190000017555834">【Redis源码分析】Redis中的LRU算法实现 - SegmentFault 思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL使用基础</title>
      <link href="/2021/04/15/MySQL%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/15/MySQL%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>MySQL是当前使用很广泛的关系型数据库，本文主要记录本人在学习MySQL过程中的学习笔记，包括MySQL的基础知识和常用查询方式</p><span id="more"></span><p>注意：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><ul><li>外键并不是通过列名实现的，而是通过定义外键约束实现的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><ul><li>删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><ul><li><p>多对多通过一个中间表（关系表）关联两个一对多关系形成多对多关系</p></li><li><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>对<code>score</code>列创建索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>​使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上<code>ADD INDEX idx_name_score (name, score);</code></p><p>​索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。</p><p>​索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引。</p><ul><li>唯一索引</li></ul><p>不适宜作为主键，但又具备唯一性约束，可以添加唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>也可以只创建唯一约束而不创建唯一索引，仍具备唯一性保证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ul><li>查询数据库表的数据，我们使用如下的SQL语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure><ul><li>条件查询的语法就是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure><ul><li>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>，<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，<code>NOT &lt;条件&gt;</code></li></ul><p>用小括号<code>()</code>表示如何进行条件的组合：</p><p><code>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#39;M&#39;;</code></p><ul><li><h3 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h3><table><thead><tr><th align="left">条件</th><th align="left">表达式举例1</th><th align="left">表达式举例2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">使用&#x3D;判断相等</td><td align="left">score &#x3D; 80</td><td align="left">name &#x3D; ‘abc’</td><td align="left">字符串需要用单引号括起来</td></tr><tr><td align="left">使用&gt;判断大于</td><td align="left">score &gt; 80</td><td align="left">name &gt; ‘abc’</td><td align="left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td align="left">使用&gt;&#x3D;判断大于或相等</td><td align="left">score &gt;&#x3D; 80</td><td align="left">name &gt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;判断小于</td><td align="left">score &lt; 80</td><td align="left">name &lt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;&#x3D;判断小于或相等</td><td align="left">score &lt;&#x3D; 80</td><td align="left">name &lt;&#x3D; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用&lt;&gt;判断不相等</td><td align="left">score &lt;&gt; 80</td><td align="left">name &lt;&gt; ‘abc’</td><td align="left"></td></tr><tr><td align="left">使用LIKE判断相似</td><td align="left">name LIKE ‘ab%’</td><td align="left">name LIKE ‘%bc%’</td><td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table></li><li><p>可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p></li><li><p>使用<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>时，还可以给每一列起个别名，结果集的列名就会被别名替换。</p></li><li><p>查询结果通常根据主键排序，可以加上<code>ORDER BY</code>子句，按照对应的查找条件由低到高排序。</p></li></ul><p>eg：<code>SELECT id, name, gender, score FROM students ORDER BY score;</code></p><p>默认采用<code>ASC</code>排序规则，即升序。可以加上<code>DESC</code>表示“倒序”：<code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code></p><p>若要进一步增加排序条件可以继续添加列名。</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li><p><code>LIMIT</code>总是设定为<code>pageSize</code>；</p></li><li><p><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</p><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p></li></ul><p>MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>使用SQL内置的<code>COUNT()</code>函数查询</p><p>SELECT COUNT(内容)  别名 FROM students;</p><p>还有如下聚合函数：</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SUM</td><td align="left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td align="left">AVG</td><td align="left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td align="left">MAX</td><td align="left">计算某一列的最大值</td></tr><tr><td align="left">MIN</td><td align="left">计算某一列的最小值</td></tr></tbody></table><p><code>GROUP BY</code>执行分组，会把<code>class_id</code>相同的列先分组，再分别计算</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p><code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</p><p>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</p><p>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</p><p>使用最常用的一种内连接——INNER JOIN</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>eg：<code>SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</code><br><code>FROM students s</code><br><code>INNER JOIN classes c</code><br><code>ON s.class_id=c.id;</code></p><p>OUT JOIN</p><p>包括：LEFT  RIGHT FULL</p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" alt="left-outer-join"></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" alt="right-outer-join"></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" alt="full-outer-join"></p><h2 id="数据库的增删查改"><a href="#数据库的增删查改" class="headerlink" title="数据库的增删查改"></a>数据库的增删查改</h2><ul><li><p>INSERT：插入新记录；</p></li><li><p>UPDATE：更新已有记录；</p></li><li><p>DELETE：删除已有记录。</p></li><li><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure></li><li><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br></pre></td></tr></table></figure></li><li><p><code>UPDATE</code>语句可以没有<code>WHERE</code>条件</p></li><li><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure></li></ul><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><p>列出所有数据库：show databases;</p><p><code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库</p><p>创建新数据库：create database+数据库名称；</p><p>删除数据库：DROP DATABASE test;</p><p>创建新的数据表：CREATE TABLE table_name；</p><p>对数据库操作前，需要将操作对象更改为当前数据库：use + 数据库名；</p><p>列出当前数据库包含的所有表：show tables；</p><p>查看表的结构:desc +表名；</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
